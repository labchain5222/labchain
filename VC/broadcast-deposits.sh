#!/usr/bin/env bash
set -euo pipefail

usage(){
  cat <<'USAGE'
Usage: ./broadcast-deposits.sh --rpc <url> --deposits <path> \
  --from <addr> --chain-id <id> --private-key <hex> \
  [--contract <address>] [--dry-run]

Options:
  --rpc <url>        Execution RPC endpoint (e.g., http://localhost:8545)
  --deposits <file>  Path to deposits.json generated by lighthouse validator-manager
  --from <address>   ETH1 account that will send the deposits
  --chain-id <id>    Chain ID for the execution network
  --private-key <k>  Hex-encoded private key for the --from account (no 0x prefix needed)
  --contract <addr>  Deposit contract address (default: 0x00000000219ab540356cBB839Cbe05303d7705Fa)
  --dry-run          Generate and display transaction payloads without broadcasting
  -h, --help         Show this help text

Requirements:
  - Foundry (cast) must be installed. Install with:
    curl -L https://foundry.paradigm.xyz | bash && foundryup
USAGE
}

RPC_URL=""
DEPOSITS_FILE=""
FROM_ADDRESS=""
CHAIN_ID=""
PRIVATE_KEY=""
DEPOSIT_CONTRACT="0x00000000219ab540356cBB839Cbe05303d7705Fa"
DRY_RUN=false

while [[ $# -gt 0 ]]; do
  case "$1" in
    --rpc)
      RPC_URL="$2"; shift 2;;
    --deposits)
      DEPOSITS_FILE="$2"; shift 2;;
    --from)
      FROM_ADDRESS="$2"; shift 2;;
    --chain-id)
      CHAIN_ID="$2"; shift 2;;
    --private-key)
      PRIVATE_KEY="$2"; shift 2;;
    --contract)
      DEPOSIT_CONTRACT="$2"; shift 2;;
    --dry-run)
      DRY_RUN=true; shift 1;;
    -h|--help)
      usage; exit 0;;
    *)
      echo "Unknown option $1" >&2; usage; exit 1;;
  esac
done

if [[ -z "$RPC_URL" || -z "$DEPOSITS_FILE" || -z "$FROM_ADDRESS" || -z "$CHAIN_ID" || -z "$PRIVATE_KEY" ]]; then
  echo "Missing required arguments" >&2; usage; exit 1
fi

if [[ ! -f "$DEPOSITS_FILE" ]]; then
  echo "Deposits file not found: $DEPOSITS_FILE" >&2; exit 1
fi

# Check if cast is installed
if ! command -v cast &> /dev/null; then
  echo "Error: 'cast' command not found" >&2
  echo "" >&2
  echo "Please install Foundry first:" >&2
  echo "  curl -L https://foundry.paradigm.xyz | bash" >&2
  echo "  foundryup" >&2
  echo "" >&2
  echo "After installation, restart your shell or run:" >&2
  echo "  source ~/.bashrc  # or ~/.zshrc" >&2
  exit 1
fi

DEPOSITS_ABS="$(cd "$(dirname "$DEPOSITS_FILE")" && pwd)/$(basename "$DEPOSITS_FILE")"
WORKDIR="$(pwd)"

# Create temp directory for output files
TEMP_DIR=$(mktemp -d)
trap "rm -rf $TEMP_DIR" EXIT

echo "[vc] Broadcasting deposits from $DEPOSITS_ABS"
echo "[vc] Using deposit contract: $DEPOSIT_CONTRACT"
echo "[vc] Sender: $FROM_ADDRESS (chain-id $CHAIN_ID)"

# Check if jq is available for JSON parsing
if ! command -v jq &> /dev/null; then
  echo "Error: jq is required but not installed" >&2
  exit 1
fi

# Count total deposits
TOTAL_DEPOSITS=$(jq '. | length' "$DEPOSITS_ABS")
echo "[vc] Found $TOTAL_DEPOSITS deposit(s) to broadcast"

# Process each deposit
for i in $(seq 0 $((TOTAL_DEPOSITS - 1))); do
  echo ""
  echo "=========================================="
  echo "[vc] Processing deposit $((i + 1))/$TOTAL_DEPOSITS"
  echo "=========================================="

  # Extract deposit data
  PUBKEY=$(jq -r ".[$i].pubkey" "$DEPOSITS_ABS")
  WITHDRAWAL_CREDS=$(jq -r ".[$i].withdrawal_credentials" "$DEPOSITS_ABS")
  SIGNATURE=$(jq -r ".[$i].signature" "$DEPOSITS_ABS")
  DEPOSIT_DATA_ROOT=$(jq -r ".[$i].deposit_data_root" "$DEPOSITS_ABS")

  echo "[vc] Pubkey: 0x$PUBKEY"

  # First verify RPC connectivity (only for first deposit)
  if [ $i -eq 0 ]; then
    echo "[vc] Verifying RPC connection to $RPC_URL..."
    echo "[vc] Command: cast block-number --rpc-url $RPC_URL"

    cast block-number --rpc-url "$RPC_URL" > "$TEMP_DIR/block.txt" 2>&1
    BLOCK_EXIT=$?
    BLOCK_NUMBER=$(cat "$TEMP_DIR/block.txt" 2>/dev/null || echo "")

    if [ $BLOCK_EXIT -ne 0 ]; then
      echo "[vc] ✗ Cannot connect to RPC (exit code: $BLOCK_EXIT)" >&2
      echo "[vc] Error output:" >&2
      cat "$TEMP_DIR/block.txt" >&2
      exit 1
    fi

    if [ -z "$BLOCK_NUMBER" ]; then
      echo "[vc] ⚠ Warning: Block number is empty but command succeeded"
    else
      echo "[vc] ✓ RPC connected, current block: $BLOCK_NUMBER"
    fi

    echo "[vc] Checking sender balance..."
    echo "[vc] Command: cast balance $FROM_ADDRESS --rpc-url $RPC_URL"

    cast balance "$FROM_ADDRESS" --rpc-url "$RPC_URL" > "$TEMP_DIR/balance.txt" 2>&1
    BALANCE_EXIT=$?
    BALANCE=$(cat "$TEMP_DIR/balance.txt" 2>/dev/null || echo "")

    if [ $BALANCE_EXIT -eq 0 ] && [ -n "$BALANCE" ]; then
      # Convert to ether for readability
      cast to-unit "$BALANCE" ether > "$TEMP_DIR/balance_eth.txt" 2>/dev/null || echo "N/A" > "$TEMP_DIR/balance_eth.txt"
      BALANCE_ETH=$(cat "$TEMP_DIR/balance_eth.txt")
      echo "[vc] ✓ Sender balance: $BALANCE wei ($BALANCE_ETH ETH)"

      # Check if balance is sufficient (need at least 512 ETH for 16 deposits)
      MIN_WEI=512000000000000000000
      if [ "$BALANCE" -lt "$MIN_WEI" ] 2>/dev/null; then
        echo "[vc] ⚠ Warning: Balance may be insufficient. Need ~512 ETH for 16 deposits." >&2
      fi
    else
      echo "[vc] ⚠ Warning: Could not retrieve balance: $BALANCE" >&2
    fi
  fi

  # Call the deposit contract
  # deposit(bytes pubkey, bytes withdrawal_credentials, bytes signature, bytes32 deposit_data_root)

  # Generate raw calldata payload
  echo "[vc] Generating transaction payload..."
  CALLDATA=$(cast calldata "deposit(bytes,bytes,bytes,bytes32)" "0x$PUBKEY" "0x$WITHDRAWAL_CREDS" "0x$SIGNATURE" "0x$DEPOSIT_DATA_ROOT")

  echo ""
  echo "=========================================="
  echo "DEPOSIT $((i + 1))/$TOTAL_DEPOSITS - RAW TRANSACTION DATA"
  echo "=========================================="
  echo ""
  echo "Contract:             $DEPOSIT_CONTRACT"
  echo "From:                 $FROM_ADDRESS"
  echo "Value:                32 ETH"
  echo "Chain ID:             $CHAIN_ID"
  echo ""
  echo "Parameters:"
  echo "  pubkey:             0x$PUBKEY"
  echo "  withdrawal_creds:   0x$WITHDRAWAL_CREDS"
  echo "  signature:          0x$SIGNATURE"
  echo "  deposit_data_root:  0x$DEPOSIT_DATA_ROOT"
  echo ""
  echo "Raw Calldata (${#CALLDATA} bytes):"
  echo "$CALLDATA"
  echo ""
  echo "----------------------------------------"
  echo "COPY-PASTE COMMAND FOR MANUAL EXECUTION:"
  echo "----------------------------------------"
  echo ""
  cat << EOF
cast send "$DEPOSIT_CONTRACT" \\
  "deposit(bytes,bytes,bytes,bytes32)" \\
  "0x$PUBKEY" \\
  "0x$WITHDRAWAL_CREDS" \\
  "0x$SIGNATURE" \\
  "0x$DEPOSIT_DATA_ROOT" \\
  --rpc-url "$RPC_URL" \\
  --chain-id "$CHAIN_ID" \\
  --from "$FROM_ADDRESS" \\
  --private-key "$PRIVATE_KEY" \\
  --value 32ether
EOF
  echo ""
  echo "=========================================="
  echo ""

  # If dry-run mode, skip broadcasting
  if [ "$DRY_RUN" = true ]; then
    echo "[vc] DRY-RUN MODE: Skipping broadcast"
    echo ""
    continue
  fi

  echo "[vc] Broadcasting transaction now..."
  echo ""

  # Run cast send and display output directly to terminal (let user see what's happening)
  set +e  # Temporarily disable exit on error
  cast send "$DEPOSIT_CONTRACT" \
    "deposit(bytes,bytes,bytes,bytes32)" \
    "0x$PUBKEY" \
    "0x$WITHDRAWAL_CREDS" \
    "0x$SIGNATURE" \
    "0x$DEPOSIT_DATA_ROOT" \
    --rpc-url "$RPC_URL" \
    --chain-id "$CHAIN_ID" \
    --from "$FROM_ADDRESS" \
    --private-key "$PRIVATE_KEY" \
    --value 32ether 2>&1 | tee "$TEMP_DIR/tx_output.txt"

  CAST_EXIT_CODE=${PIPESTATUS[0]}
  echo ""
  echo "[vc] Cast command completed with exit code: $CAST_EXIT_CODE"

  if [ $CAST_EXIT_CODE -ne 0 ]; then
    echo "[vc] ✗ Failed to broadcast deposit $((i + 1)) (exit code: $CAST_EXIT_CODE)" >&2
    set -e  # Re-enable exit on error before exiting
    exit 1
  fi

  # Try to extract transaction hash from the output
  TX_OUTPUT=$(cat "$TEMP_DIR/tx_output.txt" 2>/dev/null || echo "")

  # Try to parse as JSON first
  TX_HASH=$(echo "$TX_OUTPUT" | jq -r '.transactionHash // empty' 2>/dev/null || echo "")

  # If JSON parsing failed, try plain text extraction
  if [ -z "$TX_HASH" ]; then
    # Cast send default output includes lines like "transactionHash    0x..."
    TX_HASH=$(echo "$TX_OUTPUT" | grep -i "transactionHash\|blockHash" 2>/dev/null | grep -oE '0x[a-fA-F0-9]{64}' 2>/dev/null | head -n1 || echo "")

    if [ -z "$TX_HASH" ]; then
      # Try any 0x hash (excluding addresses which are 40 chars)
      TX_HASH=$(echo "$TX_OUTPUT" | grep -oE '0x[a-fA-F0-9]{64}' 2>/dev/null | head -n1 || echo "")
    fi
  fi

  if [ -n "$TX_HASH" ]; then
    echo "[vc] ✓ Transaction hash: $TX_HASH"
    echo "[vc] ✓ Deposit $((i + 1))/$TOTAL_DEPOSITS broadcast successfully"
  else
    echo "[vc] ⚠ Warning: Could not extract transaction hash, but command succeeded"
    echo "[vc] ✓ Deposit $((i + 1))/$TOTAL_DEPOSITS broadcast completed"
  fi

  echo ""
  echo "[vc] Waiting 2 seconds before next deposit..."
  sleep 2

  # Check if this is the last deposit
  if [ $i -lt $((TOTAL_DEPOSITS - 1)) ]; then
    echo "[vc] Continuing to next deposit ($((i + 2))/$TOTAL_DEPOSITS)..."
    echo ""
  fi
done

set -e  # Re-enable exit on error after loop completes

echo ""
echo "=========================================="
echo "[vc] All $TOTAL_DEPOSITS deposits broadcast successfully!"
echo "=========================================="